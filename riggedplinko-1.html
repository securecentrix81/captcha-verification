<!DOCTYPE html>
<html>
<head>
  <title>Plinko Game - Player vs Computer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <style>
    body { 
      margin: 0; 
      font-family: Arial, sans-serif;
      background: #222;
      color: white;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #gameContainer {
      position: relative;
    }
    canvas { 
      display: block;
      border: 2px solid #444;
      width: 100%;
      aspect-ratio: 1;
      margin:0
    }
    .score {
      font-size: 15px;
      background-color: rgba(0,0,0,0.6);
      padding: 10px;
      border-radius: 10px;
      position: absolute;
      top: 10px;
    }
    .player-score { 
      left: 10px;
      color: #4CAF50;
    }
    .computer-score {
      right: 10px;
      color: #f44336;
    }
    #turnIndicator {
      font-size: 10px;
      margin-top: 5px;
      padding: 5px;
      background: rgba(255,255,255,0.1);
      border-radius: 5px;
      text-align: center;
    }
    #dropZone {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 100%;
      pointer-events: none;
    }
    #dropZone.active {
      pointer-events: auto;
      cursor: pointer;
    }
    #dropIndicator {
      position: absolute;
      width: 40px;
      height: 40px;
      border: 3px dashed #4CAF50;
      border-radius: 50%;
      top: 30px;
      transform: translateX(-50%);
      display: none;
    }
    #instructions {
      position: absolute;
      top: 0;
      left: 0;
      background: rgba(0,0,0,0.9);
      border-radius: 10px;
      text-align: center;
      z-index: 1000;
      width: 100%;
      height: 100%;
      opacity: 1;
      display: block;
      transition: display 1s, opacity 1s;
      transition-behavior: allow-discrete;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      z-index: 1000;
      box-shadow: 0px 0px 10px white;
      display: none;
    }
    #gameOver h2 {
      font-size: 25px;
      margin-bottom: 10px;
    }
    #resetButton {
      padding: 5px 10px;
      font-size: 16px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #resetButton:hover {
      background: #45a049;
    }
    #instructionsRead {
      padding: 7px 10px;
      font-size: 16px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #instructionsRead:hover {
      background: #45a049;
    }
    .instructions-center {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
  <div class="score player-score">Player: <span id="playerScore">0</span></div>
  <div class="score computer-score">Computer: <span id="computerScore">0</span></div>
    <div id="dropIndicator"></div>
    <div id="instructions">
      <div class="instructions-center">
        <h1>Plinko</h1>
        Points: Red = 1, Yellow = 2, Green = 8<br>
        First to 40 wins!<br>
        <button id="instructionsRead">Play</button>
      </div>
    </div>
    <div id="dropZone" class="active"></div>
    <div id="gameOver">
      <h2 id="winnerText"></h2>
      <p>Final Score:</p>
      <p>Player: <span id="finalPlayerScore"></span></p>
      <p>Computer: <span id="finalComputerScore"></span></p>
      <button id="resetButton">Play Again</button>
    </div>
  </div>
  <script>
    // Game state
    let gameState = {
      playerScore: 0,
      computerScore: 0,
      isPlayerTurn: true,
      ballInPlay: false,
      turnCount: 0,
      gameOver: false
    };

    // module aliases 
    var Engine = Matter.Engine,
      Render = Matter.Render,
      Runner = Matter.Runner,
      Bodies = Matter.Bodies,
      Composite = Matter.Composite;

    // create an engine 
    var engine = Engine.create();

    // create a renderer
    var render = Render.create({
      element: document.getElementById('gameContainer'),
      engine: engine,
      options: {
        width: 1000,
        height: 1000,
        wireframes: false,
        background: '#111'
      }
    });

    let endRowCount = 11;
    let endRowSpacing = 980 / endRowCount;
    let rowSpacing = Math.sqrt(3 / 4 * endRowSpacing ** 2);
    let rowStart = 200;
    let rowCount = 9;
    let currentBall = null;
    let barriers = [];

    function setupBoard() {
      let bodies = [];

      // Bucket zones
      bodies.push(Bodies.rectangle(endRowSpacing * 1.5, 990, endRowSpacing * 3, 20, {
        isStatic: true,
        restitution: 1,
        render: {
          fillStyle: "#f00"
        }
      }));
      bodies.push(Bodies.rectangle(endRowSpacing * 9.5, 990, endRowSpacing * 3, 20, {
        isStatic: true,
        restitution: 1,
        render: {
          fillStyle: "#f00"
        }
      }));
      bodies.push(Bodies.rectangle(endRowSpacing * 4, 990, endRowSpacing * 2, 20, {
        isStatic: true,
        restitution: 1,
        render: {
          fillStyle: "#ff0"
        }
      }));
      bodies.push(Bodies.rectangle(endRowSpacing * 7, 990, endRowSpacing * 2, 20, {
        isStatic: true,
        restitution: 1,
        render: {
          fillStyle: "#ff0"
        }
      }));
      bodies.push(Bodies.rectangle(endRowSpacing * 5.5, 990, endRowSpacing, 20, {
        isStatic: true,
        restitution: 1,
        render: {
          fillStyle: "#0f0"
        }
      }));

      // Pegs
      for (let i = 0; i <= rowCount; ++i) {
        let offset = i % 2 === 0 ? 0 : -endRowSpacing / 2;
        for (let j = offset + 10 + endRowSpacing * 1.5; j <= 980 - endRowSpacing / 2; j += endRowSpacing) {
          bodies.push(Bodies.circle(j, rowStart + rowSpacing * i, 15, {
            isStatic: true,
            restitution: 1,
            render: {
              fillStyle: "#666"
            }
          }));
        }
      }

      // Bottom barriers
      for (let j = (rowCount % 2 === 0 ? 0 : -endRowSpacing / 2) + 10 + endRowSpacing * 1.5; j <= 980 - endRowSpacing / 2; j += endRowSpacing) {
        bodies.push(Bodies.rectangle(j, rowStart + rowSpacing * rowCount + 500, 30, 1000, {
          isStatic: true,
          restitution: 1,
          render: {
            fillStyle: "#666"
          }
        }));
      }

      // Walls
      bodies.push(Bodies.rectangle(10, 10, 20, 2000, {
        isStatic: true,
        restitution: 1,
        render: {
          fillStyle: "#666"
        }
      }));
      bodies.push(Bodies.rectangle(990, 10, 20, 2000, {
        isStatic: true,
        restitution: 1,
        render: {
          fillStyle: "#666"
        }
      }));
      bodies.push(Bodies.rectangle(10, 10, 2000, 20, {
        isStatic: true,
        restitution: 1,
        render: {
          fillStyle: "#666"
        }
      }));

      return bodies;
    }

    function createBarriers(isPlayer) {
      // Remove old barriers
      barriers.forEach(barrier => {
        Composite.remove(engine.world, barrier);
      });
      barriers = [];

      let invisibleWallColor = "rgba(255,255,255,0)";

      if (isPlayer) {
        let barrierRowHeight = 5 + 2 * Math.floor(Math.random() * 2)
        if (barrierRowHeight > 0 && barrierRowHeight <= rowCount) {
          let centerX = 500;
          let bottomY = rowStart + rowSpacing * rowCount;
          let topY = rowStart + rowSpacing * (rowCount - barrierRowHeight);

          // Calculate horizontal distance based on peg spacing alignment
          let horizontalDistance = (endRowSpacing / 2) * barrierRowHeight;

          // Calculate barrier length and angle
          let barrierLength = Math.sqrt(Math.pow(bottomY - topY, 2) + Math.pow(horizontalDistance, 2));
          let angle = Math.atan2(bottomY - topY, horizontalDistance);

          // Calculate center points for the barriers
          let leftBarrierX = centerX - horizontalDistance / 2;
          let leftBarrierY = (bottomY + topY) / 2;
          let rightBarrierX = centerX + horizontalDistance / 2;
          let rightBarrierY = (bottomY + topY) / 2;

          // Left barrier (going from center-bottom to left-top)
          barriers.push(Bodies.rectangle(leftBarrierX, leftBarrierY, barrierLength, 10, {
            isStatic: true,
            restitution: 1,
            angle: -angle,
            render: {
              fillStyle: invisibleWallColor
            }
          }));

          // Right barrier (going from center-bottom to right-top)
          barriers.push(Bodies.rectangle(rightBarrierX, rightBarrierY, barrierLength, 10, {
            isStatic: true,
            restitution: 1,
            angle: angle,
            render: {
              fillStyle: invisibleWallColor
            }
          }));
        }
      } else {
        let barrierRowHeight = 9
        let centerX = 500 - endRowSpacing / 2;
        let bottomY = rowStart + rowSpacing * rowCount;
        let topY = rowStart + rowSpacing * (rowCount - barrierRowHeight);

        // Calculate horizontal distance based on peg spacing alignment
        let horizontalDistance = (endRowSpacing / 2) * barrierRowHeight;

        // Calculate barrier length and angle
        let barrierLength = Math.sqrt(Math.pow(bottomY - topY, 2) + Math.pow(horizontalDistance, 2));
        let angle = Math.atan2(bottomY - topY, horizontalDistance);

        // Calculate center points for the barriers
        let leftBarrierX = centerX - horizontalDistance / 2;
        let leftBarrierY = (bottomY + topY) / 2;
        let rightBarrierX = centerX + horizontalDistance / 2;
        let rightBarrierY = (bottomY + topY) / 2;

        // Left barrier (going from center-bottom to left-top)
        barriers.push(Bodies.rectangle(leftBarrierX, leftBarrierY, barrierLength, 10, {
          isStatic: true,
          restitution: 1,
          angle: angle,
          render: {
            fillStyle: invisibleWallColor
          }
        }));


        centerX = 500 + endRowSpacing * Math.floor(endRowCount / 2);

        // Calculate center points for the barriers
        leftBarrierX = centerX - horizontalDistance / 2;
        leftBarrierY = (bottomY + topY) / 2;
        rightBarrierX = centerX + horizontalDistance / 2;
        rightBarrierY = (bottomY + topY) / 2;

        // Left barrier (going from center-bottom to left-top)
        barriers.push(Bodies.rectangle(leftBarrierX, leftBarrierY, barrierLength, 10, {
          isStatic: true,
          restitution: 1,
          angle: -angle,
          render: {
            fillStyle: invisibleWallColor
          }
        }));
      }
      Composite.add(engine.world, barriers)
    }

    function dropBall(x) {
      if (gameState.ballInPlay || gameState.gameOver) return;

      gameState.ballInPlay = true;

      // Create barriers based on whose turn it is
      createBarriers(gameState.isPlayerTurn);

      currentBall = Bodies.circle(x, 100, 20, {
        restitution: 1,
        render: {
          fillStyle: gameState.isPlayerTurn ? "#4CAF50" : "#f44336"
        },
      });

      Composite.add(engine.world, currentBall);
    }

    function calculateComputerDropPosition() {
      return Math.random() * 800 + 100;
    }

    function updateScore(points) {
      if (gameState.isPlayerTurn) {
        gameState.playerScore += points;
        window.parent.postMessage({type: "riggedplinko-1", pass: false, ended: false, playerScore: gameState.playerScore, computerScore: gameState.computerScore, playerGain: points}, "*")
        document.getElementById('playerScore').textContent = gameState.playerScore;
      } else {
        gameState.computerScore += points;
        window.parent.postMessage({type: "riggedplinko-1", pass: false, ended: false, playerScore: gameState.playerScore, computerScore: gameState.computerScore, computerGain: points}, "*")
        document.getElementById('computerScore').textContent = gameState.computerScore;
      }

      // Check for game over
      if (gameState.playerScore >= 40 || gameState.computerScore >= 40) {
        endGame();
      } else {
        // Switch turns
        gameState.isPlayerTurn = !gameState.isPlayerTurn;
        gameState.turnCount++;

        // If it's computer's turn, make move after delay
        if (!gameState.isPlayerTurn) {
          setTimeout(() => {
            let dropX = calculateComputerDropPosition();
            dropBall(dropX);
          }, 1500);
        }
      }
    }


    function endGame() {
      gameState.gameOver = true;
      window.parent.postMessage({type: "riggedplinko-1", pass: false, ended: true, playerScore: gameState.playerScore, computerScore: gameState.computerScore}, "*")
      const gameOverDiv = document.getElementById('gameOver');
      const winnerText = document.getElementById('winnerText');

      gameOverDiv.style.display = 'block';

      // Computer should always win, but just in case...
      if (gameState.computerScore >= 40) {
        winnerText.textContent = "Computer Wins!";
        winnerText.style.color = "#f44336";
      } else {
        winnerText.textContent = "You are a hacker!!!";
        winnerText.style.color = "#4CAF50";
      }

      document.getElementById('finalPlayerScore').textContent = gameState.playerScore;
      document.getElementById('finalComputerScore').textContent = gameState.computerScore;
    }

    function resetGame() {
      // Clear world
      Composite.clear(engine.world);

      // Reset game state
      gameState = {
        playerScore: 0,
        computerScore: 0,
        isPlayerTurn: true,
        ballInPlay: false,
        turnCount: 0,
        gameOver: false
      };

      // Reset UI
      document.getElementById('playerScore').textContent = '0';
      document.getElementById('computerScore').textContent = '0';
      document.getElementById('gameOver').style.display = 'none';

      // Rebuild board
      let bodies = setupBoard();
      Composite.add(engine.world, bodies);
      window.parent.postMessage({type: "riggedplinko-1", pass: false, ended: false, playerScore: gameState.playerScore, computerScore: gameState.computerScore, reset: true}, "*")
    }

    // Initialize board
    let bodies = setupBoard();
    Composite.add(engine.world, bodies);

    // run the renderer
    Render.run(render);

    // create runner
    var runner = Runner.create();

    // run the engine
    Runner.run(runner, engine);

    // Handle ball settling
    Matter.Events.on(engine, 'afterUpdate', function () {
      if (currentBall && currentBall.speed < 0.1 && currentBall.position.y > rowStart + rowSpacing * rowCount && !currentBall.settled) {
        currentBall.settled = true;

        let bucketIndex = Math.ceil((currentBall.position.x - ((rowCount % 2 === 0 ? 0 : -endRowSpacing / 2) + 10 + endRowSpacing * 1.5)) / endRowSpacing);

        let points = 0;
        if ((bucketIndex >= 0 && bucketIndex <= 2) || (bucketIndex >= 8 && bucketIndex <= 10)) {
          points = 1;
        } else if (bucketIndex >= 3 && bucketIndex <= 7 && bucketIndex !== 5) {
          points = 2;
        } else if (bucketIndex === 5) {
          points = 8;
        }

        // Remove ball after short delay
        setTimeout(() => {
          window.parent.postMessage({type: "riggedplinko-1", pass: false, ended: false, playerScore: gameState.playerScore, computerScore: gameState.computerScore}, "*")
          if (currentBall) {
            Composite.remove(engine.world, currentBall);
            currentBall = null;
            gameState.ballInPlay = false;
          }
          updateScore(points);
        }, 1000);
      }
    });

    // Mouse interaction for player
    const dropZone = document.getElementById('dropZone');
    const dropIndicator = document.getElementById('dropIndicator');

    dropZone.addEventListener('mousemove', (e) => {
      if (gameState.isPlayerTurn && !gameState.ballInPlay && !gameState.gameOver) {
        const rect = render.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        dropIndicator.style.display = 'block';
        dropIndicator.style.left = x + 'px';
      }
    });

    dropZone.addEventListener('mouseleave', () => {
      dropIndicator.style.display = 'none';
    });

    dropZone.addEventListener('click', (e) => {
      if (gameState.isPlayerTurn && !gameState.ballInPlay && !gameState.gameOver) {
        const rect = render.canvas.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 1000;
        dropIndicator.style.display = 'none';
        dropBall(Math.max(30, Math.min(970, x)));
      }
    });

    document.getElementById("instructionsRead").addEventListener("click", () => {
      document.getElementById("instructions").style = "display:none;opacity:0"
    })

    // Reset button
    document.getElementById('resetButton').addEventListener('click', resetGame);
    let timeIdle = 0
    setInterval(() => {
      if (currentBall && currentBall.speed < 0.1) {
        ++timeIdle
      } else {
        timeIdle = 0
      }
      if (timeIdle > 15) {
        Matter.Body.applyForce(currentBall, currentBall.position, {
          x: 0.003 * (Math.random() - 0.5),
          y: 0.003 * (Math.random() - 0.5)
        }, 1000)
      }
      if (timeIdle > 30) {
        Matter.Body.applyForce(currentBall, currentBall.position, {
          x: 0.006 * (Math.random() - 0.5),
          y: 0.006 * (Math.random() - 0.5)
        }, 1000)
      }
      if (timeIdle > 60) {
        Matter.Body.applyForce(currentBall, currentBall.position, {
          x: (timeIdle - 60) ** 2 * 0.01 * (Math.random() - 0.5),
          y: (timeIdle - 60) ** 2 * 0.01 * (Math.random() - 0.5)
        }, 1000)
      }
    }, 1000 / 15)
  </script>
</body>
</html>
